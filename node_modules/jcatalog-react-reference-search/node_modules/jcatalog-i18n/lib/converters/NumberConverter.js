'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ERROR_CODE = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Converter2 = require('./Converter');

var _Converter3 = _interopRequireDefault(_Converter2);

var _ParseError = require('./ParseError');

var _ParseError2 = _interopRequireDefault(_ParseError);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ERROR_CODE = exports.ERROR_CODE = 'error.parse.number';

var floatNumberReg = /^-?\d+\.?\d*$/;
var intNumberReg = /^-?\d+$/;

var NumberConverter = function (_Converter) {
  _inherits(NumberConverter, _Converter);

  function NumberConverter(format, groupSep, decSep, decSepUseAlways) {
    _classCallCheck(this, NumberConverter);

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(NumberConverter).call(this));

    _this._format = format;
    _this._groupSep = groupSep;
    _this._decSep = decSep;
    _this._decSepUseAlways = decSepUseAlways || false;

    _this._decimalFormat = format.substring(format.lastIndexOf('.') + 1);

    if (format.indexOf('.') !== -1) {
      _this._isValid = function (value) {
        return floatNumberReg.test(value);
      };
    } else {
      _this._isValid = function (value) {
        return intNumberReg.test(value);
      };
    }
    return _this;
  }

  _createClass(NumberConverter, [{
    key: '_throwIfNumberIsNotValidFormString',
    value: function _throwIfNumberIsNotValidFormString(value) {
      var orginValue = value;
      var stringValue = value;
      if (this._groupSep) {
        stringValue = stringValue.replace(new RegExp('\\' + this._groupSep, 'g'), '');
      }

      if (this._decSep !== undefined) {
        stringValue = stringValue.replace(this._decSep, '.');
      }

      if (!this._isValid(stringValue)) {
        throw new _ParseError2.default(ERROR_CODE, { value: orginValue });
      }
    }
  }, {
    key: 'valueToString',
    value: function valueToString(num) {
      var number = num;
      if (number === null) {
        return '';
      }

      if (typeof number === 'string') {
        return number;
      }

      var neg = '-';
      var forcedToZero = false;

      if (isNaN(number)) {
        number = 0;
        forcedToZero = true;
      }

      var returnString = '';
      if (this._format.indexOf('.') !== -1) {
        var decimalPortion = this._decSep;

        // round or truncate number as needed
        number = number.toFixed(this._decimalFormat.length);

        var decimalValue = number % 1;
        var decimalString = decimalValue.toFixed(this._decimalFormat.length).toString();
        decimalString = decimalString.substring(decimalString.lastIndexOf('.') + 1);

        for (var i = 0; i < this._decimalFormat.length; i++) {
          if (this._decimalFormat.charAt(i) === '#' && decimalString.charAt(i) !== '0') {
            decimalPortion += decimalString.charAt(i);
          } else if (this._decimalFormat.charAt(i) === '#' && decimalString.charAt(i) === '0') {
            var notParsed = decimalString.substring(i);
            if (notParsed.match('[1-9]')) {
              decimalPortion += decimalString.charAt(i);
            } else {
              break;
            }
          } else if (this._decimalFormat.charAt(i) === '0') {
            decimalPortion += decimalString.charAt(i);
          }
        }

        if (decimalPortion === this._decSep && !this._decSepUseAlways) {
          decimalPortion = '';
        }

        returnString += decimalPortion;
      } else {
        number = Math.round(number);
      }

      var ones = Math.floor(number);
      if (number < 0) {
        ones = Math.ceil(number);
      }

      var onesFormat = '';
      if (this._format.indexOf('.') === -1) {
        onesFormat = this._format;
      } else {
        onesFormat = this._format.substring(0, this._format.indexOf('.'));
      }

      var onePortion = '';
      if (!(ones === 0 && onesFormat.substr(onesFormat.length - 1) === '#') || forcedToZero) {
        // find how many digits are in the group
        var oneText = Math.abs(ones).toString();
        var groupLength = 9999;
        if (onesFormat.lastIndexOf(',') !== -1) {
          groupLength = onesFormat.length - onesFormat.lastIndexOf(',') - 1;
        }

        var groupCount = 0;
        for (var k = oneText.length - 1; k > -1; k--) {
          onePortion = oneText.charAt(k) + onePortion;
          groupCount++;
          if (groupCount === groupLength && k !== 0) {
            onePortion = (this._groupSep || '') + onePortion;
            groupCount = 0;
          }
        }

        // account for any pre-data 0's
        if (onesFormat.length > onePortion.length) {
          var padStart = onesFormat.indexOf('0');
          if (padStart !== -1) {
            var padLen = onesFormat.length - padStart;

            // pad to left with 0's
            while (onePortion.length < padLen) {
              onePortion = '0' + onePortion;
            }
          }
        }
      }

      if (!onePortion && onesFormat.indexOf('0', onesFormat.length - 1) !== -1) {
        onePortion = '0';
      }

      returnString = onePortion + returnString;

      // handle special case where negative is in front of the invalid characters
      if (number < 0) {
        returnString = neg + returnString;
      }

      if (returnString) {
        if (returnString === this._decSep) {
          returnString = '0';
        } else if (returnString.indexOf(this._decSep) === 0) {
          returnString = '0' + returnString;
        }
      }

      return String(returnString);
    }
  }, {
    key: 'stringToValue',
    value: function stringToValue(strValue) {
      var stringValue = strValue || null;
      if (stringValue === null) {
        return null;
      }

      this._throwIfNumberIsNotValidFormString(stringValue);

      var valid = '1234567890.-';

      // now we need to convert it into a number
      if (this._groupSep) {
        while (stringValue.indexOf(this._groupSep) > -1) {
          stringValue = stringValue.replace(this._groupSep, '');
        }
      }

      stringValue = stringValue.replace(this._decSep, '.');

      var validText = '';
      for (var i = 0; i < stringValue.length; i++) {
        if (valid.indexOf(stringValue.charAt(i)) > -1) {
          validText = validText + stringValue.charAt(i);
        }
      }

      var result = parseFloat(validText);

      if (this._format.indexOf('.') !== -1) {
        result = result.toFixed(this._decimalFormat.length);
      } else {
        result = result.toFixed();
      }

      return +result;
    }
  }]);

  return NumberConverter;
}(_Converter3.default);

exports.default = NumberConverter;